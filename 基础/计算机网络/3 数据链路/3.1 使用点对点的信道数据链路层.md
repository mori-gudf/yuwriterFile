# 3.1 使用点对点的信道数据链路层


---
## 3.1.1 数据链路与帧
### 概念区分
* 链路：一个结点到**相邻**结点的一段物理线路（有线或无线），中间没有其它交换点。
  * 计算机之前通信需要很多段这样的节点
* 数据链路：**物理线路**+实现**协议**的硬件软件
  * 常见使用**网络适配器**，一般的适配器都包括了数据链路层和物理层这两层的功能。

---
### 规程与帧
* 规程其实就是早期协议
* ==帧==是协议的数据单元

---

节点通信图，只有三层协议：

![点对点]($resource/%E7%82%B9%E5%AF%B9%E7%82%B9.png)

通信步骤
* 结点A的数据链路层把网络层交下来的**IP数据报**添加**首部**和**尾部**封装成帧。
*  结点A把封装好的**帧**发送给结点B的数据链路层。
* 若结点B的数据链路**层收到的帧**无差错，则从收到的帧中提取出**IP数据报**上交给上面的网络层；否则丢弃这个帧。

忽略物理层复杂度，简单认为帧可以直接到达对面。

## 3.1.2 三个基本问题

### 封装成帧
* 分组交换的基本单位：ip数据报
* 封装：首+数据报+尾
* **帧定界**：控制字符SOH (Start Of Header)放在一帧的最前面，表示帧的首部。另一个控制字符EOT (End Of Transmission)表示帧结束
  * SOH  01（二进制是00000001）
  * EOT 04（二进制是00000100）
* MTU：提高效率，尽可能提高数据报在帧中数据长度**占比**。每一种链路层协议都规定了所能传送的帧的数据部分长度上限
![帧]($resource/%E5%B8%A7.png)

### 透明传输
* 【帧定界错误】帧定界与传输内容不可冲突，作为特殊字符，如果传输内容存在帧定界，会出现**帧定界错误**
* 【错误时机】传输非文本文件，如二进制代码的计算机程序或图像等，某个字节二进制码跟帧定界冲突。这样就会导致无法**透明传输** 
![定界错误]($resource/%E5%AE%9A%E7%95%8C%E9%94%99%E8%AF%AF.jpeg)
* 【解决透明传输问题】字节填充：转义字符“ESC”(其十六进制编码是1B，二进制是00011011)，**转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符**
![字节填充]($resource/%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85.jpeg)

### 差错检测
【比特差错】现实的通信链路都不会是理想的，0可能传成1，1可能变成0。（误码率跟信噪比有关）
【差错校验】在数据链路层广泛使用了**循环冗余检验CRC** (CyclicRedundancy Check)的检错技术。其实就是**约定除数**，模2运算，**取余补尾**进行“加密”。。“解密”就是每一帧通用除以余数，为0则对。

#### CSC原理：

* 【CSC】数据分组，如每组k bit。如传输 M = 101001 （k = 6），计算好**冗余码**。构成一个帧发送出去，一共发送(k + n)位。虽增大传输开销，但解决数据差错问题。
* 【冗余码】用二进制的模 2 运算
(相加不进位)进行2n乘 M 的运算，这相当于在**M后面添加n个0**。得到的(k + n)位的数除以收发双方事先==商定==的长度为(n + 1)位的除数P，得出商是Q而==余数是R==（n 位，比P少一位）。它就是==冗余码FCS（帧校验序列）==
    *  FCS是序列
    * CSC是方法
  * 例子：上述M = 101001（即k = 6）。假定除数P = 1101（即n = 3）。经模2除法运算后的结果是：商Q =110101（这个商并没有什么用处），而余数R = 001
  * ![cscfcs]($resource/cscfcs.jpg)

* 校验冗余码：把收到的==每一个帧==都除以同样的**除数P**（模2运算），然后检查得到的**余数R**。 
* 


