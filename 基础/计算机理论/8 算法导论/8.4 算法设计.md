# 8.4 算法设计


## 8.4.1 贪心算法

不追求最优解，解决问题即可，省去最优解的耗费。
当前状况做最优，无需回溯。

例子：
  * 找零钱：（标准纸币设计已经符合最优，但问题本质还是局部最优，找回钱即可。纸币+硬币的组合，大面值纸币+小面值硬币）
  * 装箱：尽可能装满一个箱子，箱子容量固定，物品有大有小乱序存放。（不一定最后装的是方案是用最少的箱子。但也解决里装箱问题。尽可能多的物件装进一个箱子）
  * 删数：每次删一个数字保证留下的都是最大的。175438，每次从左到右两两对比，第一次出现右边的数小于左边的时候，删左边，否则删最后。【因为每次删都相当于减少一位，当然是尽可能删左边位数大的值也大的】
## 8.4.2 分治法
分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

* 适用条件：
  * 问题缩小到一定程度就特别**容易解决**。复杂度随规模增加
  * 问题**可以分解**为若干规模相同的问题，其具有最优子结构
  * 子问题可以**合并** 【必备条件】
  * 子问题互相独立，不包含公共**子问题** 【效率条件】 如斐波那契，重复子问题不如用动态规划。
* 步骤：
  * 规模n分解成k个子问题，找各部分解，最后合并。
  * 耗时：子问题工作量，问题个数，合并问题所需工作量
  * 图解一般套路
![1597674490474]($resource/1597674490474.jpg)
  * 例子：一袋子金块（n块，n的k次幂），优秀雇员1获得最重的，第二的雇员获得最轻的。
    * 解法：n中寻找最大和最小
      * 分治处理1:最小规模，只有一个金子，不合法，两个金子，只需要一次max一次min就可以查找到max和min【2次】
      * 把子集n对半分，每一半进行max和min【2倍的T（n/2）次】
      * 将对半分的max和min进行一次max和min【+2次】
      * 结果 当n=2时，比较次数T（n）=2；当n＞2时，比较次数T（n）=2T（n/2）+2，n=2k。


## 8.4.3 动态规划
借用**中间结果表格，空间替换时间**，从规模最小的子问题求解开始，一个接一个逐步利用规模较小子问题的解求解规模较大问题，进而最终求解原问题。

* 例子：求解DAG的最短路径
  * ![dag]($resource/dag.jpeg)
  * 结构可以线性化，区别于dfs搜索，此题只是找**点到s最短路径**，而不是判断搜点和点。所以只需要一趟循环建立一维距离表，遍历W权重二维数组，不断动态更新一维距离表即可。。
![动态规划]($resource/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.jpg)

![dp]($resource/dp.jpeg)

## 8.4.4 回溯法
从空的状态空间树开始，第一层状态树是对第一个了解分量的所有尝试，第二层则展开第二个分量，以此类推。【dfs+节点拓展条件】
  * 核心步骤
    *  【拓展】：有可能有解，继续下一层子分量的尝试。
    * 【回溯】：无解，返回双亲，重新根据上一层分量的下一个分量进行尝试，【拓展】。

  * 例子
     * n皇后问题：横纵斜不攻击  
       * n=1 没有意义
       * n=2 n=3 横纵都会攻击 无解
       * n=4 如图
![回溯]($resource/%E5%9B%9E%E6%BA%AF.png)
       * **代码  太难了 见leecode 后续补**

